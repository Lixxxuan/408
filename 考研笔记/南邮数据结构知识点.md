## 习题知识点

> 下边的知识点是我在做南京邮电大学考研历年真题时遇到自己不会的题时整理出来的。第九部分是做mooc课后习题时整理出来的，希望对各位同学有所帮助。

### 1.线性表

1. 设链表非空，采用**不带表头结点的单循环链表，一个链表指针指向表的第一个结点** 这种链表可以在O(1)时间内在表尾插入一个新结点。

   解释：可以在头结点后插入一个和头结点一样的结点，然后修改头结点的值为新结点的值，将插入的结点指为新的头结点，时间复杂度为O(1)。

2. 在末尾插入和删除节点，带头结点的双循环链表  最节省时间。

3. 在单链表中设置头结点的作用是 ①对第一个结点的操作和对其他结点的操作统一。②空表和非空表的操作也统一。

4. **取** 第i个元素及其前趋元素 利用顺序表

   **存取** 第i个元素及其前趋元素 利用顺序表。 

   **存取** 第i个元素及其前后元素 利用顺序表。 

5. 线性表采用链式存储时，即存储了数据本身，又存储了数据间的关系。顺序存储是通过数组下标来表示数据之间的关系。

6. 对线性表进行二分搜索时，线性表应为有序顺序表，且以表的中点为划分点。 错误

   解释： 如果是单数的话就是中间 如果是双数的话 一定不是中间

7. 合并两个长度分别为 m 和 n 的有序表，最坏情况下需要比较 m+n-1次。

8. 链式存储设计时，节点内的存储单元地址==一定连续==

   不同节点的存储单元地址可以不连续，节点内的存储单元地址必须连续

9. 需要分配较大的空间，插入和删除不需要移动元素的线性表，其存储结构为 静态链表。

10. 线性表的两种存储结构各有哪些优缺点？

    链式存储：优点：插入和删除不需要移动大量元素。 缺点：大量访问操作时不如顺序存储结构。

    顺序存储：可随机存储表中任意元素，方便灵活，效率高。 缺点：插入和删除需大量移动元素。

11. 头指针，头结点，表头结点的区别

    不管有没有头结点，头指针始终指向链表的第一个结点（头结点是带头结点的链表中的第一个结点）；在表头结点之前设置的结点为头结点；表头结点为链表中第一个存储数据元素的结点。

12. 数组作为一种线性结构，因此可以与线性表一样进行数据元素的插入删除运算    错误

    解释：数组的空间是提前分配好的，不能直接进行插入操作


### 2.栈和队列

1. 将中缀表达式转换为后缀表达式，进入堆栈的元素为表达式中的 运算符 ，计算后缀表达式中进入堆栈的元素为 操作数。

2. 循环队列是一种顺序存储结构

3. 消除递归不一定要用栈来实现。比如，对于斐波那契数列，可以使用递推的方式来实现； 但是使用栈，一定可以将递归消去。

4. 栈和队列是逻辑结构，不是存储结构。

5. 阐述栈和队列在非线性数据结构中的应用

   栈和队列可以在二叉树和图的非递归遍历中应用

6. 页面替换算法用到了队列

7. 使用两个栈模拟队列

   对S2的出栈模拟出队，若S2为空，则先将S1中的所有元素送入S2。对S1的入栈模拟入队，==若S1满，必须先保证S2为空，才能将S1的元素插入S2==。

8. 什么是队列的上溢现象？

   在队列的顺序存储结构中，设队头指针为front，队尾指针为rear，队列的容量为maxnum。当有元素要加入队列时，若rear = maxnum，则会发生队列的上溢现象，此时不能将该元素加入队列。“假溢出”现象：队列中余有足够的空间，但元素却不能入队。可以用循环队列解决。


### 3.数组

1. 根据==三对角==对阵压缩方法，
   将A[1..n] [1..n]压缩至B[0..3n-3]时，aij与k的对应关系为：k=2i+j-3；
   将A[1..n] [1..n]压缩至B[1..3n-2]时，aij与k的对应关系为：k=2i+j-2；

2. 稀疏矩阵压缩存储后，必定失去随机存取功能。

   解释：压缩后，使用三元组进行存储，已经不是简单的线性结构，所以不可以随机存取。

3. ==若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，该图拓扑排序存在，可能不唯一。加上条件A[i] [i+1]全为1才是唯一的==

4. 有一个100*90的稀疏矩阵,非0元素有10个,设每个整型数占2字节,则用三元组表示该矩阵时,所需的字节数是 66

   解释：每个非零元素占3 * 2=6个字节，共10个非零元素，需6 * 10 = 60 个字节； 此外，还一般要用三个整数来存储矩阵的行数、列数和总元素个数，又需要3*2 = 6个字节； 总共：60 + 6 = 66 个字节。

5. m*n的稀疏矩阵中有t个非零元素，==快速转置的时间复杂度为O(n+t)==


### 4.树和二叉树

1. 扩充二叉树

- 扩充二叉树：在二叉树出现空子树的位置增加空树叶所形成的二叉树

- 外部结点：空树叶结点

- 内部结点：非空结点

- 外路径长度：扩充二叉树中所有外部结点到根结点的路径长度之和

- 内路径长度：扩充二叉树中所有内部结点到根节点的路径长度之和

![image-20220928101407515](https://typora-dzsq.oss-cn-hangzhou.aliyuncs.com/img/image-20220928101407515.png)

![image-20220928102035994](https://typora-dzsq.oss-cn-hangzhou.aliyuncs.com/img/image-20220928102035994.png)

2. B树一般用于文件索引系统。

3. 线索二叉树的好处

   容易确定树中任何一个节点在某种遍历顺序下的前驱或者后继

4. 从堆中删除一个元素的时间复杂度为O(log2n)

5. 平衡二叉树每次调整的对象都是**最小不平衡子树**，即插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。（P21 简答题第一题）

6. 哈夫曼编码是不等长编码，ASCII为等长编码。

7. 为什么采用哈夫曼编码？（P22）

   对出现频率高的字符使用较少的码位编码，对于出现频率低的字符使用较多的码位编码，减少总体文本长度。所以采用哈夫曼编码。

8. 一个索引文件，如果经常需要插入和删除元素，宜采用 B+树 做索引

9. 如果一个有向图代表一个工程之间的领先关系，当算法执行出现拓扑排序不能包括图中全部顶点的情况时，应当检查 ==是否是反自反的==。（P25 填空第四题）

10. 存储B树中每个结点的存储块的大小是否相同，为什么?

    相同的，因为每个结点都是顺序表的形式，不需要在添加元素时动态分配它的内存空间。

11. 引入B树的根本原因是 为了减少外搜索的磁盘访问次数，为修改过程提供简单的平衡算法。在有 n 个元素的 m阶B树中，搜索一个元素的算法需要访问外存的次数至多为 log[m/2]向上取整 [(n+1)/2]+1。

12. 中序遍历的时间复杂度为O(n)

13. 森林中有N个非叶结点，则对应的二叉树中右指针域为空的结点有N+1个。

14. B树只能随机存取，B+树可以随机和顺序存取。

15. ==F,C是二叉树的两个结点，使用**先序和后序遍历**可以判断F是C的祖先。==

    原因：①如果F是C的祖先，先序遍历时，F在C的前边；后序遍历时，F在C的后边，相对位置改变。②如果F，C是兄弟结点，那么先序遍历和后序遍历时相对位置不变。

16. 最小生成树：普利姆算法适合求解边稠密的图，克鲁斯卡尔算法适用于求解 边稀疏的图。

17. 在关键字==随机分布==的情况下，用二叉树排序树的方法进行查找，其查找长度与 折半查找 量级相当。

    原因：在随机的情况下，二叉排序树的平均查找长度的数据量级为O(log2n)，与折半查找同数量级。

18. 设高度（根节点高度为1）为h的二叉树只有度为0和度为2的结点，则此类二叉树结点数至少为 2h-1

    解释：只有度为0和2两种情况,即每个结点要么没有子节点,要么有两个子节点(概念),这样一来除了根节点,每层至少两个结点,共h层,应有2(h-1)+1(除根节点外每层都有2个,最后加上1个根节点),化简得2h-1个

19. 求AVL每个结点的平衡因子时使用后序遍历。 2011年最后一题。

20. 任何无向图都可以转换成生成树。 错误

    解释：只有无向连通图才可以转换为生成树。

21. ==图采用邻接表存储时最小生成树Prim算法时间复杂度为O(n^2)==

22. 线索二叉树是一种物理结构

23. n个结点线索二叉树含有的 n+1 个线索

24. 二叉判定树的树形取决于 表中元素个数

25. 优先权队列就是构造小根堆的过程

26. 树的路径长度是从树根到每个节点的路径长度的总和

27. 在二叉树中，m是n的祖先，使用==后序遍历==可以找到 m 到 n的路径

28. 二叉树在线索化后，仍不能有效求解后序线索二叉树求后序后继

29. 后序线索树遍历仍需要 栈 的支持

31. 树和二叉树的区别 ①二叉树的度至多为2，树无此限制  ②二叉树有左右子树之分，树无此限制  ③二叉树允许为空，树一般不允许为空

32. ==非空二叉树先序和后序相反是什么形态？   二叉树高度和结点个数相同==

32. ==层序遍历和中序遍历能唯一确定一颗二叉树==

33. 完全二叉树必定是二叉平衡树   错误          因为二叉平衡树是有序的


### 5.散列表

1. 一个好的散列函数满足以下条件：①能快速计算 ②具有均匀性

2. 线性探测法的缺点：容易产生聚集现象，从而导致搜索时间增加

3. 对于除留余数法的模M，一般如何选择

   一般取不大于表长的最大素数

4. 删除散列表可行且有效的方法？说明理由

   在拉链法情况下可以物理清除。在开放定址法情况下，不能做物理删除，只能做标记删除。

   删除时只将其标记为NeverUsed，而不实际删除。这样可以跳过该元素继续查找，插入时可在该位置插入元素。P(22)

5. 哈希表的结点中只包含数据元素自身的信息，不包含任何指针。 ×

   散列法存储的思想是由关键字值决定数据的存储地址         √

6. ==拉链法又称开散列法，开地址法又称为闭散列法==     （易错）

7. 散列查找中的平均查找长度（查找效率）和 散列函数，装填因子，处理冲突的方法 有关。

8. 用哈希（散列）方法处理冲突（碰撞）时可能出现堆积（聚集）现象，下列选项中，会受堆积现象直接影响的是 （D）

   解释：存储是基于查找的，所以不能算作直接影响。

   - ```
     存储效率
     ```

   - ```
     数列函数
     ```

   - ```
     装填（装载）因子
     ```

   - ```
     平均查找长度
     ```

9. 开地址法散列到同一个地址而引起的“堆积问题”是由于 ==同义词或非同义词之间发生冲突==。

### 6.图

1. 拓扑排序：无有向回路（无环）

2. 迪斯杰特拉算法按==路径长度递增==次数逐一产生最短路径。

3. 有n个顶点的有向强连通图最多有 n(n-1) 条边。

4. 设有向图用邻接表表示，计算第 i 个顶点的入度方法是 扫描邻接表中的所有边结点，统计 adjvex = i 的边结点个数。

5. 判断一个图中是否有环的方法：拓扑排序，dfs（思路：==如果dfs遍历到的点之前已经被遍历过，说明有环==），求关键路径

6. 如果具有n个顶点的图是一个环，则它有 n 棵生成树。

   解释：因为n个顶点构成的环共有n条边，去掉其中任意一条便是一棵生成树，所以共有n种情况。

7. ==Prime算法思想==：从某一个顶点出发，选择与它关联的最小权值的边，将其顶点加入到顶点集s中，之后就从一个顶点在s集中，另一个顶点不在s集中，选择出权值最小的边，把对应的顶点加入到s集中，直到所有顶点都加到s集中。

8. 图采用邻接表时最小生成树Prim算法的时间复杂度为O(n^2)

10. 只要无向连通图中没有权值相同的边，则其最小生成树唯一

11. 最小生成树代价唯一（形状可能不唯一）

12. 若一个有向图具有==有序==的拓扑排序序列，则它的邻接矩阵必定为 ==三角==

13. 图的DFS遍历思想相当于二叉树的先序遍历

14. 若一个有向图的顶点不能排在一个拓扑序列中，则可判定该有向图 ==含有顶点数目大于1的强连通分量==。

15. 一个有n个顶点和n条边的无向图一定是 有环的。

    解释：不一定是连通图。比如构成两个环的时候。

15. 对于有 n 个顶点的图，普利姆算法的时间复杂度是O(n^2)

### 7.排序算法

1. 快排中，每次划分后，将划分的两个长度不等的子表分别排序。为提高排序效率，应对其中哪个子表先排序，为什么？

   先对长度较小的排序，为了减少栈空间的大小。

2. 快速排序最好情况，分割元素将序列分割成两个大小一样的子序列。（例题：P13）

3. 是否在多有情况下快排都优于直接插入排序，为什么？
   快排适用于数据量大（上百万）的情形，插入排序适合数据量小的情形。

4. 如果用三个元素中间值法，可以避免将待排序元素划分在分割元素一边的情形发生，快速排序的优越性得以体现。（P22）

5. 排序的时间复杂度只需记住三个即可。直接插入和冒泡排序的最好时间复杂度为O(n)。快速排序的最坏时间复杂度为O(n^2)。

6. 采用什么措施可改善快速排序的最坏情况的时间性能？

   ①选取随机数作为枢轴

   ②使用左端，右端和中心的中值作为枢轴

   ③每次选取数据集的中位数作为枢轴

7. 倒排文件是对次关键字建立索引的。（不知道考不考）

8. 将两个长度均为n的有序表合成一个有序表，关键字比较的最多次数和最少次数为 2n-1 和 n。

9. 顺序查找n个元素的顺序表，当使用哨兵结点时，若查找失败，则比较关键字的次数为 n+1 次。

   解释：n个元素都要比较一次，但都不成功，最后监视哨也要比较一次，比较成功，一共比较n+1次。

10. 直接插入排序一趟不能确定一个元素的最终位置

11. 以下数据结构查找效率最低的是  C

    A.二叉搜索树            B.有序顺序表          C.堆                D.二叉平衡树

    解释：堆是用来排序的，在查找时是无序的。

12. 对任意n个关键字排序的==比较次数==至少为 ==log2(n!) 向上取整==

13. 每趟排序结束后都至少能够确定一个元素最终位置的方法是 简单选择排序，冒泡排序，快排，堆排

14. 排序趟数与序列初始状态无关的排序算法是  直接插入，简单选择，基数排序，归并排序

15. 对任意7个关键字进行基于比较的排序，至少进行 13 次关键字之间的两两比较。

    解释：对任意 n 个关键字排序的比较次数至少为  `log2(n!)`
    
16. 快速排序在==被排序的数据完全无序==情况下最易发挥长处

### 8.其他

2. 算法的输入可以有0个或多个，输出有1个或多个

3. 数据结构是带有结构的数据元素的集合。

4. 算法的健壮性是指当输入不合法数据时，程序会采取紧急措施。

5. 文件结构是外存数据的组织方式，常见的四种文件结构包括 顺序文件，索引文件，链式文件，索引顺序文件。

6. 四种逻辑结构，分别为集合，线性，图，树形结构

7. ==逻辑结构，存储结构和运算之间的关系？==

   数据的逻辑结构反应数据元素之间的逻辑关系，与存储结构无关。数据的存储结构是数据在计算机中的表示。数据的运算是对数据定义的一组操作，运算是定义在逻辑结构上的，与存储结构无关，而运算的实现依赖于存储结构。

7. 若逻辑结构相同但存储结构不同，则为不同的数据结构。

   例1： 如线性表的顺序表和链表，二者的逻辑结构相同而存储结构不同，为不同的数据结构。

   例2： 二叉树的顺序存储和链式存储

   若存储结构相同但逻辑结构不同，则为不同的数据结构。

   例：链式存储的树和图

9. 度量一个程序执行时间有哪些方法？优缺点是什么？

   ①事后统计。缺点：1.必须先实际运行 2. 执行时间依赖于计算机硬件，软件等环境因素，有时容易掩盖算法本身的优势。

   ②事前分析估算。解决了事后统计的缺点。

10. 影响时间复杂度O(n)的因素有 问题规模。（计算机软硬件不能选）

11. O渐近上界，Ω渐近下界，θ渐进确界 

12. 计算机中有顺序存储，链式存储，索引存储，哈希存储四种存储方式

13. 可以用==抽象数据类型==定义一个完整的数据结构

14. 算法原地工作是指==算法所需的辅助空间是常量==

15. 折半查找和二叉排序树的时间性能有时不相同

    二叉排序树的查找性能和数据的输入顺序有关，最坏情况形成单支树，查找长度为O(n)

16. ==对n个元素的有序顺序表和无序顺序表进行顺序查找，判断下边三种情况下平均查找长度是否相同==

    - 查找失败

    不相同，对有序顺序表，当查找的关键字值大于要查找的元素时，就查找失败，不必查找到表尾。而对于无序顺序表，必须查找到表尾才能确定查找失败。

    - 查找成功，且表中只有一个关键字等于给定K的元素

    相同。两者找到表中关键字值等于给定值时就停止查找。

    - 查找成功，且表中有若干个关键字等于给定K的元素

    不相同。有序顺序表关键字相同的元素排列在一起，只要找到第一个就可以找到其他关键字相同的元素。而无序顺序表必须查找表中全部元素才能确定相同关键字元素全部找出来了，所以所需时间不同。

17. 当执行函数时，其局部变量的存储一般采用 栈结构 进行存储。

### 9. MOOC课件习题

1. 算法和程序==最显著的区别==？

   算法是有穷的，而程序不一定满足有穷性。如操作系统

2. ==算法和程序的区别和联系？==

   联系：程序是计算机指令的有序集合，是算法用某种设计语言的表述，是算法在计算机上的实现。

   区别：语言描述上不同。程序必须用规定的程序设计语言，而算法可以用自然语言，伪代码等等。算法是有穷的，而程序不一定满足有穷性。如操作系统

3. 数据是可被计算机识别并处理加工的对象

   数据元素是由数据组成的具有一定意义的基本单位

   数据项是数据元素中不可分割的最小单位

   数据结构是由某一数据对象及该对象中所有数据元素之间的关系组成的。

   数据的逻辑结构是数据元素之间的逻辑关系

   数据的存储结构是数据元素之间的关系在计算机内的表示形式

   数据的运算是数据被使用的方式

![image-20221208102625160](https://typora-dzsq.oss-cn-hangzhou.aliyuncs.com/img/image-20221208102625160.png)

   ![image-20221208103120546](https://typora-dzsq.oss-cn-hangzhou.aliyuncs.com/img/image-20221208103120546.png)

![image-20221208114058519](https://typora-dzsq.oss-cn-hangzhou.aliyuncs.com/img/image-20221208114058519.png)

4. 行三元组表 行优先

   列三元组表 列优先

5. 无序表查找成功的平均查找长度 (n+1)/2

   ​            查找失败的平均查找长度 n

   有序表查找成功 (n+1)/2

   ​            ==查找失败 2+n/2==

​        ![image-20221209095514534](https://typora-dzsq.oss-cn-hangzhou.aliyuncs.com/img/image-20221209095514534.png)

6. 邻接表的优缺点

   优点：便于统计边的数目；空间效率高

   缺点：不便于判断顶点之间是否有边；不便于计算有向图各个顶点的度

   邻接矩阵的优缺点：

   优点：便于判断两个顶点是否有边；便于计算各个顶点的度

   缺点：不便于统计边的数目；空间复杂度高

7. 可以存在多个关键路径
8. 拉链法散列在同一个链表的结点称为 同义词




